Fibonacci numbers: 
    F<n> = 0 if n = 0,
           1 if n = 1, 
           F<n-1> + F<n-2> for n>1
    Fibonacci number grows as faster as power of 2, for eaxmple F<30> is over a million and F<100> already have 21 digits. In general F<n> ~ 2^0.649n


Gereatest common divisor:
    For integers a and b, g(a,b) is greatest integer which divides both.
    Lemma: Let a' be the reminder when a is divided by b, then 
        g(a,b) = g(b, a') = g(a', b)

Program's runtime measurement:
    Runtime depends on program and system used to run it whereas increament because of system realted factors like speed of computer, system architecture, compiler being used and detail of memory hirerarchy etc. is not so straight forward to calcuate but it multiply runtime by a (large) constant. so we need a method to measure runtime which ignore constant multiples.

    Asymptotic runtime measures how runtime scale with input size. Below shows how relative scaling of most useful one for runtime measurement:
        log(n) > sqrt(n) > n > nlog(n) > n^2 > 2^n

    f(n) = O(g(n)) is read as f is Big O g and represents that f(n) scales slower in compare to g(n) if there exist constants N and c so that for all n>=N, f(n)<= c.g(n) 
    Note that growth rate of 5n^2 + 3n + 2 is same as n^2
    Benefit of using Big-O notation: 
        - clarifies growth-rate
        - cleans up notation
        - can ignore system related complicated details as its asymptotic
    Cons definetily include that we lose detail of measured runtime 
    common rules:
        - multiplicative constant could be omitted
        - leave lower order term which becomes less significant as n grows
        and hence 5n^2 + 3n + 2 becomes O(n^2)
        - In order to keep bigger picture, we treat two functions equivalent if they differ only by multiplicative constant (f1/f2<= constant1 and f2/f2 <= constant2). 

    Other notation: 
        As Big-O denoted <= omega denoted >= and and theta denotes ==

    Other runtime measurement notes:
        - Addition of n-bit number takes time roughly propotional to n

Useful logarithms for runtime measurement:
    - log<a>(n^k) = klog<a>notation
    - log<a>(nm) = log<a>n + log<a>m 
    - n^(log<a>b) = b^(log<a>n)
    - log<n>a . log<b>a = log<b>n

Pisano period: 
    For any integer m≥2, the sequence F<n> mod m is periodic. The period always starts with 01 and is known as Pisano period.
    Using above, in order to calculate caclate F<n> mod m where n is very large:
        - Find pisano period length for mod m by finding index where 01 again appears while claculating mod
        - Divide n by pisano period length to get remonder r
        - F<r> mod m will be equal to F<n> mod m
    Note:
        - (a+b)%n = ((a%n) + (b%n)) % n <- use it with property of fibonacci number and itwill help you overcome integer overflow problem

Additional Reading resource:
    Sanjoy Dasgupta, Christos Papadimitriou, and Umesh Vazirani. Algorithms (1st Edition). McGraw-Hill Higher Education. 2008.
        - Computing Fibonacci numbers: Section 0.2
        - Properties of Fibonacci numbers: Exercises 0.2–0.4
        - Greatest common divisor: Section 1.2.3
        - Big-O notation and growth rate: Section 0.3
    Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein. Introduction to Algorithms (3rd Edition). MIT Press and McGraw-Hill. 2009.
        - Greatest common divisor: Section 31.2
